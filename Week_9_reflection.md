# Reflection: Recursive and Iterative Practice

Looking back at my code, I wrote it the way I did because I was focused on making it easy to follow and understand. I used separate variables like `last_digit`, `new_input`, and `result` because it helped me keep track of what was happening at each step. I wasn’t thinking about making the code shorter or more optimized yet. I just wanted it to work and be clear.

One thing I learned is that recursive functions don’t have to be as long as I made them. I saw how they can be written in fewer lines, especially when the logic is simple. I also learned that too many return statements, even if they work, can make the code look messy or hard to follow. Moving forward, I’ll try to keep things cleaner by using one return statement when I can.

Another takeaway is testing. I did test my functions using print statements, but I didn’t always structure those tests in a way that clearly shows things are working. I need to do better there, maybe by adding comparisons or simple checks that prove the output is what I expect.

Translating the recursive methods into iterative versions also taught me a lot. It forced me to think differently about how data flows. With recursion, I’m relying on the function to call itself and store values along the way. With iteration, I have to handle everything with variables and loops. It was a good challenge, especially with Fibonacci, where tracking previous values matters.

There were also some similarities between my code and the instructor’s. I included docstrings, wrote in a clear structure, and even tried to optimize a couple of my methods with shorter versions. So I know I’m on the right track, just need to clean things up a bit more.

Going forward, I’ll keep a few things in mind. I’ll try to simplify my code where it makes sense, reduce the number of return statements, and do better with writing useful test cases. I’ll also make sure I comment my code with purpose, not just to explain what’s happening but to show why it’s happening.

Overall, this was a solid reminder that good code is more than just working code. It should also be clean, readable, and tested. I’m going to take these lessons into the next assignment.
